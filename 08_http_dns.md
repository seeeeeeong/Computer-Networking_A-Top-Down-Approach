# 2.2 웹과 HTTP

웹은 온디맨드(on-demand) 방식으로 사용자가 원할 때 원하는 것을 수신한다.  
개인은 또한, 웹 상에서 많은 정보를 얻고 상호작용할 수 있다.

---

## 2.2.1 HTTP 개요

- 웹 애플리케이션 계층 프로토콜은 웹의 중심이다.  
- RFC 1945, RFC 7230, RFC 7540에 정의되어 있다.  
- HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의한다.

### 웹 페이지(web page)

- 웹 페이지는 객체(object)로 구성된다.  
- 객체는 단일 URL로 지정할 수 있는 하나의 파일(HTML, JPEG 이미지, 자바스크립트 등)이다.  
- 대부분 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다.  
- 예: HTML 텍스트 + 5개의 JPEG 이미지 = 6개의 객체  
- 기본 HTML 파일은 페이지 내부 다른 객체를 해당 객체의 URL로 참조한다.  
- URL 예:  
  `http://www.school.edu/picture.gif`  
  - 호스트 이름: www.school.edu  
  - 경로 이름: picture.gif

### 웹 브라우저와 클라이언트

- 웹 브라우저는 HTTP의 클라이언트 측 구현체이다.  
- 브라우저와 클라이언트 용어를 혼용해서 사용한다.  
- 브라우저는 요청한 웹 페이지를 보여주고, 여러 인터넷 항해 기능을 제공한다.

### 웹 서버

- 웹 서버는 URL로 지정 가능한 웹 객체를 갖고 있다.  
- 사용자가 요청 시:  
  1. 브라우저가 HTTP 요청 메시지를 서버에 보낸다.  
  2. 서버는 요청을 수신 후, 객체를 포함한 HTTP 응답 메시지를 보낸다.

### HTTP와 TCP

- HTTP는 TCP를 전송 프로토콜로 사용한다.  
- HTTP 클라이언트는 서버에 TCP 연결을 시작한다.  
- TCP 연결 후, HTTP 요청/응답 메시지를 소켓 인터페이스로 송수신한다.  
- TCP는 신뢰적 데이터 전송을 보장하므로, HTTP는 손실 복구를 걱정하지 않아도 된다.

### 비상태(stateless) 프로토콜

- HTTP는 클라이언트 상태 정보를 유지하지 않는다.  
- 같은 객체를 여러 번 요청해도 서버는 상태를 기억하지 않고 매번 객체를 보낸다.

---

## 2.2.2 비지속 연결과 지속 연결

### 비지속(non-persistent) 연결

- 각 HTTP 요청/응답 쌍이 별도의 TCP 연결에서 이루어진다.  
- 예: HTML 파일 + 10개 이미지 → 총 11개 TCP 연결이 생성되고 종료됨.  
- 연결 과정:  
  1. TCP 연결 시도 및 소켓 생성  
  2. HTTP 요청 메시지 전송  
  3. 서버가 객체 포함 응답 메시지 전송  
  4. 서버가 TCP 연결 종료 요청  
  5. TCP 연결 종료  
  6. 클라이언트는 HTML 파일을 받고 내부 이미지 참조 확인 후, 2~5 단계 반복  
- TCP 연결 설정 및 종료에 2 RTT 필요 → 느림  
- HTTP 1.0은 비지속 연결 사용

### 지속(persistent) 연결

- HTTP/1.1은 기본적으로 지속 연결을 사용  
- TCP 연결을 요청 후 닫지 않고 유지함  
- 같은 연결로 여러 요청/응답 전송 가능  
- 파이프라이닝(pipelining): 요청을 기다리지 않고 연속 전송 가능  
- 서버는 일정 시간 미사용 시 연결 닫음

---

## HTTP 메시지 포맷

### HTTP 요청 메시지

- ASCII 텍스트 형태, 사람이 읽을 수 있음  
- 구조: 요청 라인 + 헤더 라인 + 빈 줄 + (선택적) 메시지 바디

#### 요청 라인

- 세 필드로 구성:  
  - 메서드(method): GET, POST, HEAD, PUT, DELETE 등  
  - URL  
  - HTTP 버전  

#### 주요 헤더

- Host: 요청 대상 호스트  
- Connection: 지속 연결 여부 지정  
- User-Agent: 클라이언트 정보  
- Accept-Language: 선호하는 언어  

#### 메시지 바디

- GET은 비어있음  
- POST는 폼 데이터 등 포함 가능

---

### HTTP 응답 메시지

- 상태 라인 + 헤더 라인 + 빈 줄 + (선택적) 메시지 바디

#### 상태 라인

- HTTP 버전, 상태 코드, 상태 메시지 포함  
- 주요 상태 코드 예:  
  - 200 OK: 성공  
  - 301 Moved Permanently: 영구 이동  
  - 400 Bad Request: 잘못된 요청  
  - 404 Not Found: 문서 없음  
  - 505 HTTP Version Not Supported

#### 주요 헤더

- Connection: 연결 유지 여부  
- Date: 응답 생성 날짜  
- Server: 서버 정보  
- Last-Modified: 객체 최종 수정일  
- Content-Length: 바이트 길이  
- Content-Type: MIME 타입  

---

## 2.2.4 쿠키(cookie)

- HTTP는 비상태 프로토콜이지만, 쿠키로 상태 유지 가능  
- 쿠키 동작 흐름:  
  1. 서버는 식별번호 생성 후 Set-Cookie 헤더로 응답  
  2. 브라우저는 쿠키 저장  
  3. 이후 요청 시 쿠키 포함하여 서버에 식별 정보 전송  
- 이를 통해 서버는 사용자 식별 가능

---

## 2.2.5 웹 캐싱(cache)

- 웹 캐시는 원본 서버 대신 요청을 처리하는 프록시 서버  
- 저장 공간에 최근 객체 사본 저장  
- 요청 처리 속도 향상, 트래픽 감소 효과  
- 캐시는 클라이언트와 서버 역할 모두 수행

### 캐시 동작 과정

1. 브라우저가 웹 캐시에 요청  
2. 캐시에 객체가 있으면 즉시 응답  
3. 없으면 원본 서버에 요청 후 응답 받아 저장 및 전달

### 캐싱의 이점

- 응답 시간 단축  
- 인터넷 트래픽 및 병목 감소  
- CDN(콘텐츠 전송 네트워크)을 통한 지역 분산 캐싱

### 조건부 GET (Conditional GET)

- 캐시가 최신인지 확인하는 방법  
- 요청에 `If-Modified-Since` 헤더 포함  
- 서버는 수정 없으면 `304 Not Modified` 응답

---

## 2.2.6 HTTP/2

- HTTP/2는 HTTP/1.1 단점 개선  
- 하나의 TCP 연결에서 멀티플렉싱 지원  
- 요청 우선순위, 서버 푸시, 헤더 압축 제공  
- HTTP 메시지를 프레임으로 분할, 인터리빙 후 재조립  
- HOL(Head of Line) 블로킹 문제 완화

### 서버 푸시

- 서버가 클라이언트 요청 없이도 추가 객체를 전송 가능  
- 요청 지연 최소화

---

## HTTP/3 (개요)

- QUIC 프로토콜 위에서 작동하는 최신 HTTP 버전  
- UDP 기반 전송으로 지연 최소화  
- 아직 완전 표준화 전 단계

---
